<html>
<head>
  <style>/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/
body {
  font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;
  font-size: 16px;
  margin: 0;
  padding: 0;
  color: #252519;
  background-color: #F5F5FF
}

table {
  display: table;
  border-collapse: separate;
  border-color: grey;
  margin-bottom: 10px;
  border-bottom: solid #ddd 1px;
}
td {
  vertical-align: top;
}

.header {
    margin-top: 30px;
}

.header p {
    margin-left: 20px;
}

.dependencies table {
    border: none;
    width: 99.99%;
    margin-left: 20px;
    font-size: 16px;
}

.dependencies .dotted {
    width: 99%;
}

.dependencies .dotted hr {
    margin-bottom: -6px;
    noshade: noshade;
    border-top: none;
    color: transparent;
    border-left: none;
    border-bottom: dotted #bbb 1px;
    border-right: none;
    background-color: transparent;
    height: 0;
  }

.content {
    width: 100%;
    border-collapse: collapse;
}

h1.project-name {
    display: inline;
    font-size: 34px;
}

h2.project-version {
    display: inline;
    margin-left: 10px;
    margin-top: 0;
    font-size: 18px;
}

.code_cell {
  border: none;
  margin: 0px;
  padding-left: 20px;
  width: 55%;
  border-left: solid #E5E5EE 1px;
  font-size: 10pt;
  vertical-align: top;
  overflow: hidden;
  background-color: #F5F5FF;
}

td.comment_cell {
  border: none;
  margin: 0px;
  padding-left: 55px;
  width: 410px;
  padding-right: 20px;
  vertical-align: top;
  max-width: 410px;
  min-width: 410px;
  background-color: #FFF;
}

pre {
  float: left;
  height: 100%;
  margin-top: 0;
}

code {
  font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace !important;
  font-size: 10pt;
}
.hljs {
  display: inline-block;
  overflow-x: auto;
  padding: 0 0.5em 0.5em 0.5em;
  /*background: #F0F0F0;*/
}

.footer {
    text-align: center;
}

/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}</style>
  <script>/*! highlight.js v9.5.0 | BSD3 License | git.io/hljslicense */
!function(e){var n="object"==typeof window&&window||"object"==typeof self&&self;"undefined"!=typeof exports?e(exports):n&&(n.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return n.hljs}))}(function(e){function n(e){return e.replace(/[&<>]/gm,function(e){return I[e]})}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0===t.index}function a(e){return k.test(e)}function i(e){var n,t,r,i,o=e.className+" ";if(o+=e.parentNode?e.parentNode.className:"",t=B.exec(o))return R(t[1])?t[1]:"no-highlight";for(o=o.split(/\s+/),n=0,r=o.length;r>n;n++)if(i=o[n],a(i)||R(i))return i}function o(e,n){var t,r={};for(t in e)r[t]=e[t];if(n)for(t in n)r[t]=n[t];return r}function u(e){var n=[];return function r(e,a){for(var i=e.firstChild;i;i=i.nextSibling)3===i.nodeType?a+=i.nodeValue.length:1===i.nodeType&&(n.push({event:"start",offset:a,node:i}),a=r(i,a),t(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:i}));return a}(e,0),n}function c(e,r,a){function i(){return e.length&&r.length?e[0].offset!==r[0].offset?e[0].offset<r[0].offset?e:r:"start"===r[0].event?e:r:e.length?e:r}function o(e){function r(e){return" "+e.nodeName+'="'+n(e.value)+'"'}l+="<"+t(e)+w.map.call(e.attributes,r).join("")+">"}function u(e){l+="</"+t(e)+">"}function c(e){("start"===e.event?o:u)(e.node)}for(var s=0,l="",f=[];e.length||r.length;){var g=i();if(l+=n(a.substr(s,g[0].offset-s)),s=g[0].offset,g===e){f.reverse().forEach(u);do c(g.splice(0,1)[0]),g=i();while(g===e&&g.length&&g[0].offset===s);f.reverse().forEach(o)}else"start"===g[0].event?f.push(g[0].node):f.pop(),c(g.splice(0,1)[0])}return l+n(a.substr(s))}function s(e){function n(e){return e&&e.source||e}function t(t,r){return new RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var u={},c=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");u[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?c("keyword",a.k):E(a.k).forEach(function(e){c(e,a.k[e])}),a.k=u}a.lR=t(a.l||/\w+/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),null==a.r&&(a.r=1),a.c||(a.c=[]);var s=[];a.c.forEach(function(e){e.v?e.v.forEach(function(n){s.push(o(e,n))}):s.push("self"===e?a:e)}),a.c=s,a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var l=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=l.length?t(l.join("|"),!0):{exec:function(){return null}}}}r(e)}function l(e,t,a,i){function o(e,n){for(var t=0;t<n.c.length;t++)if(r(n.c[t].bR,e))return n.c[t]}function u(e,n){if(r(e.eR,n)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?u(e.parent,n):void 0}function c(e,n){return!a&&r(n.iR,e)}function g(e,n){var t=N.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function h(e,n,t,r){var a=r?"":y.classPrefix,i='<span class="'+a,o=t?"":C;return i+=e+'">',i+n+o}function p(){var e,t,r,a;if(!E.k)return n(B);for(a="",t=0,E.lR.lastIndex=0,r=E.lR.exec(B);r;)a+=n(B.substr(t,r.index-t)),e=g(E,r),e?(M+=e[1],a+=h(e[0],n(r[0]))):a+=n(r[0]),t=E.lR.lastIndex,r=E.lR.exec(B);return a+n(B.substr(t))}function d(){var e="string"==typeof E.sL;if(e&&!x[E.sL])return n(B);var t=e?l(E.sL,B,!0,L[E.sL]):f(B,E.sL.length?E.sL:void 0);return E.r>0&&(M+=t.r),e&&(L[E.sL]=t.top),h(t.language,t.value,!1,!0)}function b(){k+=null!=E.sL?d():p(),B=""}function v(e){k+=e.cN?h(e.cN,"",!0):"",E=Object.create(e,{parent:{value:E}})}function m(e,n){if(B+=e,null==n)return b(),0;var t=o(n,E);if(t)return t.skip?B+=n:(t.eB&&(B+=n),b(),t.rB||t.eB||(B=n)),v(t,n),t.rB?0:n.length;var r=u(E,n);if(r){var a=E;a.skip?B+=n:(a.rE||a.eE||(B+=n),b(),a.eE&&(B=n));do E.cN&&(k+=C),E.skip||(M+=E.r),E=E.parent;while(E!==r.parent);return r.starts&&v(r.starts,""),a.rE?0:n.length}if(c(n,E))throw new Error('Illegal lexeme "'+n+'" for mode "'+(E.cN||"<unnamed>")+'"');return B+=n,n.length||1}var N=R(e);if(!N)throw new Error('Unknown language: "'+e+'"');s(N);var w,E=i||N,L={},k="";for(w=E;w!==N;w=w.parent)w.cN&&(k=h(w.cN,"",!0)+k);var B="",M=0;try{for(var I,j,O=0;;){if(E.t.lastIndex=O,I=E.t.exec(t),!I)break;j=m(t.substr(O,I.index-O),I[0]),O=I.index+j}for(m(t.substr(O)),w=E;w.parent;w=w.parent)w.cN&&(k+=C);return{r:M,value:k,language:e,top:E}}catch(T){if(T.message&&-1!==T.message.indexOf("Illegal"))return{r:0,value:n(t)};throw T}}function f(e,t){t=t||y.languages||E(x);var r={r:0,value:n(e)},a=r;return t.filter(R).forEach(function(n){var t=l(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}),a.language&&(r.second_best=a),r}function g(e){return y.tabReplace||y.useBR?e.replace(M,function(e,n){return y.useBR&&"\n"===e?"<br>":y.tabReplace?n.replace(/\t/g,y.tabReplace):void 0}):e}function h(e,n,t){var r=n?L[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),-1===e.indexOf(r)&&a.push(r),a.join(" ").trim()}function p(e){var n,t,r,o,s,p=i(e);a(p)||(y.useBR?(n=document.createElementNS("http://www.w3.org/1999/xhtml","div"),n.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):n=e,s=n.textContent,r=p?l(p,s,!0):f(s),t=u(n),t.length&&(o=document.createElementNS("http://www.w3.org/1999/xhtml","div"),o.innerHTML=r.value,r.value=c(t,u(o),s)),r.value=g(r.value),e.innerHTML=r.value,e.className=h(e.className,p,r.language),e.result={language:r.language,re:r.r},r.second_best&&(e.second_best={language:r.second_best.language,re:r.second_best.r}))}function d(e){y=o(y,e)}function b(){if(!b.called){b.called=!0;var e=document.querySelectorAll("pre code");w.forEach.call(e,p)}}function v(){addEventListener("DOMContentLoaded",b,!1),addEventListener("load",b,!1)}function m(n,t){var r=x[n]=t(e);r.aliases&&r.aliases.forEach(function(e){L[e]=n})}function N(){return E(x)}function R(e){return e=(e||"").toLowerCase(),x[e]||x[L[e]]}var w=[],E=Object.keys,x={},L={},k=/^(no-?highlight|plain|text)$/i,B=/\blang(?:uage)?-([\w-]+)\b/i,M=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,C="</span>",y={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},I={"&":"&amp;","<":"&lt;",">":"&gt;"};return e.highlight=l,e.highlightAuto=f,e.fixMarkup=g,e.highlightBlock=p,e.configure=d,e.initHighlighting=b,e.initHighlightingOnLoad=v,e.registerLanguage=m,e.listLanguages=N,e.getLanguage=R,e.inherit=o,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/},e.C=function(n,t,r){var a=e.inherit({cN:"comment",b:n,e:t,c:[]},r||{});return a.c.push(e.PWM),a.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),a},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.METHOD_GUARD={b:"\\.\\s*"+e.UIR,r:0},e});hljs.registerLanguage("nimrod",function(t){return{aliases:["nim"],k:{keyword:"addr and as asm bind block break case cast const continue converter discard distinct div do elif else end enum except export finally for from generic if import in include interface is isnot iterator let macro method mixin mod nil not notin object of or out proc ptr raise ref return shl shr static template try tuple type using var when while with without xor yield",literal:"shared guarded stdin stdout stderr result true false",built_in:"int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 float float32 float64 bool char string cstring pointer expr stmt void auto any range array openarray varargs seq set clong culong cchar cschar cshort cint csize clonglong cfloat cdouble clongdouble cuchar cushort cuint culonglong cstringarray semistatic"},c:[{cN:"meta",b:/{\./,e:/\.}/,r:10},{cN:"string",b:/[a-zA-Z]\w*"/,e:/"/,c:[{b:/""/}]},{cN:"string",b:/([a-zA-Z]\w*)?"""/,e:/"""/},t.QSM,{cN:"type",b:/\b[A-Z]\w+\b/,r:0},{cN:"number",r:0,v:[{b:/\b(0[xX][0-9a-fA-F][_0-9a-fA-F]*)('?[iIuU](8|16|32|64))?/},{b:/\b(0o[0-7][_0-7]*)('?[iIuUfF](8|16|32|64))?/},{b:/\b(0(b|B)[01][_01]*)('?[iIuUfF](8|16|32|64))?/},{b:/\b(\d[_\d]*)('?[iIuUfF](8|16|32|64))?/}]},t.HCM]}});</script>
</head>
<body>
  <table class='content'>
<tr>
  <td class='comment_cell'><div class='header'>
  <h1 class='project-name'>literate</h1><h2 class='project-version'>0.0.1</h2>
  <p>Documentation generator for Nim, inspired by Marginalia</p>
  <table class='dependencies'>
    <tr>
      <td>nim >= 0.14.3</td>
      <td class="dotted"><hr></td>
      <td></td>
    </tr>
    <tr>
      <td>compiler</td>
      <td class="dotted"><hr></td>
      <td></td>
    </tr>
  </table>
</div></td>
  <td class='code_cell'><pre><code class="nimrod"></code></pre></td>
</tr>
<tr>
  <td class='comment_cell'></td>
  <td class='code_cell'><pre><code class="nimrod">import os, strutils, osproc, json, templates, sequtils, nre
import templates, packages.docutils.rstgen, parseopt2, options</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Reads a source file as separate lines and formats HTML entities.</td>
  <td class='code_cell'><pre><code class="nimrod">proc read_source_file*(file: string): seq[string] =
  let str = readFile(file & ".nim").replace("&lt;", "&lt;").replace("&gt;", "&gt;")
  str.split("\n")

proc read_nimble(file: string): seq[string] = readFile(file & ".nimble").split("\n")</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'><h2>Type definitions</h2></td>
  <td class='code_cell'><pre><code class="nimrod"></code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Object to hold a nimble dependency.</td>
  <td class='code_cell'><pre><code class="nimrod"></code></pre></td>
</tr>
<tr>
  <td class='comment_cell'></td>
  <td class='code_cell'><pre><code class="nimrod">type Dependency = object
  project : string
  version : string</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Object to hold each section (code and documentation)</td>
  <td class='code_cell'><pre><code class="nimrod">type Section = object
  docs: string
  code: string</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Regex to match a comment</td>
  <td class='code_cell'><pre><code class="nimrod">let comment_matcher = re"^\s*##\s?"</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Ignore the first line if it's a shebang.</td>
  <td class='code_cell'><pre><code class="nimrod">proc remove_shebang(lines: seq[string]) : seq[string] =
  result = if lines[0].startswith("#!"):
      lines[1..&lt;lines.len()]
    else:
      lines</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Determine whether a line contains a declaration or not.</td>
  <td class='code_cell'><pre><code class="nimrod">proc match_declaration(line: string): bool =
  let clean = line.strip()
  clean.startsWith("type") or clean.startsWith("class")

proc process_dependencies(lines: seq[string]): seq[Dependency] =
  map(
    filter(lines, proc(line: string): bool = line.startsWith("requires")),
    proc(line: string): Dependency = Dependency(project: line[10..&lt;line.len()-1], version: ""))

proc parse_version(lines: seq[string]): string =
  let parsed = filter(lines, proc(line: string): bool = line.startsWith("version"))
  if parsed.len() == 1:
    parsed[0].split("=")[1].strip.replace("\"", "")
  else:
    ""
proc parse_decription(lines: seq[string]): string =
  let parsed = filter(lines, proc(line: string): bool = line.startsWith("description"))
  if parsed.len() == 1:
    parsed[0].split("=")[1].strip.replace("\"", "")
  else:
    ""</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>The header will contain info about project's name, version, description and dependencies.
All taken from the Nimble definition file.</td>
  <td class='code_cell'><pre><code class="nimrod">proc generate_header(dependencies: seq[Dependency], version: string, project: string, description: string) : string =
  tmpli html"""
  &lt;div class='header'&gt;
    &lt;h1 class='project-name'&gt;$(project)&lt;/h1&gt;&lt;h2 class='project-version'&gt;$(version)&lt;/h2&gt;
    &lt;p&gt;$(description)&lt;/p&gt;
    &lt;table class='dependencies'&gt;

      $for dependency in dependencies {
      &lt;tr&gt;
        &lt;td&gt;$(dependency.project)&lt;/td&gt;
        &lt;td class="dotted"&gt;&lt;hr&gt;&lt;/td&gt;
        &lt;td&gt;$(dependency.version)&lt;/td&gt;
      &lt;/tr&gt;
      }

    &lt;/table&gt;
  &lt;/div&gt;"""</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Parse a sequence of lines.</td>
  <td class='code_cell'><pre><code class="nimrod">proc parse_source(source_lines : seq[string]) : seq[Section] =

  var lines = source_lines

  for linenum in 2..&lt;lines.len():
    if lines[linenum].match(re"coding[:=]\s*([-\w.]+)").isSome():
      lines.delete(linenum, linenum)
      break

  var sections :seq[Section]= @[]

  var has_code = false
  var docs_text = ""
  var code_text = ""</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Process the `lines`.</td>
  <td class='code_cell'><pre><code class="nimrod">for line in lines:

        var process_as_code = false

        if line.match(comment_matcher).isSome():
            if has_code:
                sections.add(Section(docs: docs_text, code: code_text))
                has_code = false
                docs_text = ""
                code_text = ""
            docs_text = docs_text & line.replace(comment_matcher, "") & "\n"

        else:
            process_as_code = true

        if process_as_code:
            if code_text != "" and match_declaration(line):
                  sections.add(Section(docs: docs_text, code: code_text))
                  has_code = false
                  docs_text = ""
                  code_text = ""

            has_code = true
            code_text = code_text & line & "\n"

  sections.add(Section(docs: docs_text, code: code_text))
  sections</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'><h2>HTLM generation.</h2></td>
  <td class='code_cell'><pre><code class="nimrod">proc naive_markdown(chunk: string): string =
  let stripped = chunk.strip()
  if stripped.startsWith("# "):
      "&lt;h2&gt;" & stripped[2..&lt;stripped.len()] & "&lt;/h2&gt;"
  elif stripped.startsWith("## "):
      "&lt;h3&gt;" & stripped[3..&lt;stripped.len()] & "&lt;/h3&gt;"
  else:
      chunk</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Creates a documentation cell's HTML based on a `Section`.</td>
  <td class='code_cell'><pre><code class="nimrod">proc create_row*(section: Section): string =
  let markdowned =  naive_markdown(section.docs)
  tmpli html"""
  &lt;tr&gt;
    &lt;td class='comment_cell'&gt;$(markdowned)&lt;/td&gt;
    &lt;td class='code_cell'&gt;&lt;pre&gt;&lt;code class="nimrod"&gt;$(section.code)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
  &lt;/tr&gt;"""</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Create the documentation's footer.</td>
  <td class='code_cell'><pre><code class="nimrod">proc create_footer(): string =
  tmpli html"""
  &lt;div class="footer"&gt;
    Generated by &lt;a href="https://github.com/ruivieira/literate"&gt;Literate&lt;/a&gt;.
    &nbsp;&nbsp;Syntax highlighting provided by &lt;a href="https://highlightjs.org/"&gt;highlight.js&lt;/a&gt;
  &lt;/div&gt;
  """</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Main HTML generation.</td>
  <td class='code_cell'><pre><code class="nimrod">proc create_html(sections: seq[Section], css: string, js: string) : string =
  tmpli html"""
  &lt;html&gt;

  &lt;head&gt;
    &lt;style&gt;$(css)&lt;/style&gt;
    &lt;script&gt;$(js)&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;table class='content'&gt;

      $for section in sections {
        $(create_row(section))
      }

    &lt;/table&gt;
    $(create_footer())
    &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
  &lt;/body&gt;
  &lt;/html&gt;"""</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'>Compile time inclusion of Javascript and CSS.</td>
  <td class='code_cell'><pre><code class="nimrod">const js = slurp"js/highlight.pack.js"
const css = slurp"js/styles/default.css"</code></pre></td>
</tr>
<tr>
  <td class='comment_cell'><h2>Command line interface</h2></td>
  <td class='code_cell'><pre><code class="nimrod">const usageString =
  """Usage: literature [OPTIONS]
Options:
    -f                  Nim input file
    -o                  Output HTML (default: uberdoc.html)
    -h --help           print this help menu
"""
var output = "uberdoc.html"
var input = none(string)

for kind, key, val in getopt():
  case kind
  of cmdArgument: discard
  of cmdShortOption, cmdLongOption:
    case key
    of "help", "h": echo usageString
    of "f": input = some(val)
    of "o": output = val
    else: discard
  of cmdEnd: discard

if input.isNone:
  echo "Must specify a source file."
else:

  let input_file = input.get()
  if not fileExists(input_file & ".nim") or not fileExists(input_file & ".nimble"):

    echo "Both $1.nim and $1.nimble must exist." % [input_file]

  else:

    echo "Generation $2 from $1" % [input_file, output]

    let lines = read_source_file(input_file)

    let nimble_lines = read_nimble(input_file)

    let (dependencies, version, description) = (process_dependencies(nimble_lines), parse_version(nimble_lines), parse_decription(nimble_lines))

    let initial_section = generate_header(dependencies, version, input_file, description)

    let sections = parse_source(
      remove_shebang(lines)
    )

    let all_sections = Section(docs: initial_section, code: "") & sections

    let html = create_html(all_sections, css, js)

    writeFile(output, html)</code></pre></td>
</tr>
  </table>
<div class="footer">
  Generated by <a href="https://github.com/ruivieira/literate">Literate</a>.
  &nbsp;&nbsp;Syntax highlighting provided by <a href="https://highlightjs.org/">highlight.js</a>
</div>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
